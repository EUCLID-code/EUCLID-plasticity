{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is here applied to discover path-dependent material behavior, i.e., elastoplastic material models and generalized standard material models. Elastoplasticity In a single experiment with complex geometry (a), point-wise displacements (b) and global reaction forces (i) are measured. A quadrilateral finite element mesh is constructed (c) to interpolate the displacement data. The resulting displacement field (d) is differentiated to arrive at the strain field (e). The material model library (f) is constructed (here based on a Fourier ansatz). Based on this library and for given material parameters theta and H , the stresses can be calculated by applying a classical elastic predictor - plastic corrector return mapping algorithm at each load step in the data set, while the history variables are updated at each step (g). Based on the stresses, the internal and external virtual works and hence the internal (h) and external (i) force imbalances are calculated, contributing to the cost function. Finally, the cost function is minimized jointly with a sparsity promoting regularization term (j) to generate a set of solutions out of which a solution with low cost and high parsimony is automatically selected. Generalized standard materials From a mechanical test on a specimen with complex shape (a), the strain field over the specimen surface is acquired using digital image correlation (DIC) (b) , and the reaction force at the boundary is measured using a load cell. Introducing a model library, the residuals of the weak form of linear momentum balance in the interior (c) and at the boundary (d) can be expressed as functions of the material parameters theta . By minimizing the sum of squared residuals of the linear momentum balance along with a sparsity promoting regularization term (e), the thermodynamic potentials (f) are discovered as parsimonious mathematical formulae. About the documentation The documentation contains detailed information for the most important functions (subroutines). For each function, the input arguments and output arguments are provided. The documentation can be browsed by using the search box. The provided example helps to understand the workflow of EUCLID, it can be executed using the code and data provided on GitHub . The data used in the publication can be downloaded from the ETH Research Collection .","title":"Home"},{"location":"#elastoplasticity","text":"In a single experiment with complex geometry (a), point-wise displacements (b) and global reaction forces (i) are measured. A quadrilateral finite element mesh is constructed (c) to interpolate the displacement data. The resulting displacement field (d) is differentiated to arrive at the strain field (e). The material model library (f) is constructed (here based on a Fourier ansatz). Based on this library and for given material parameters theta and H , the stresses can be calculated by applying a classical elastic predictor - plastic corrector return mapping algorithm at each load step in the data set, while the history variables are updated at each step (g). Based on the stresses, the internal and external virtual works and hence the internal (h) and external (i) force imbalances are calculated, contributing to the cost function. Finally, the cost function is minimized jointly with a sparsity promoting regularization term (j) to generate a set of solutions out of which a solution with low cost and high parsimony is automatically selected.","title":"Elastoplasticity"},{"location":"#generalized-standard-materials","text":"From a mechanical test on a specimen with complex shape (a), the strain field over the specimen surface is acquired using digital image correlation (DIC) (b) , and the reaction force at the boundary is measured using a load cell. Introducing a model library, the residuals of the weak form of linear momentum balance in the interior (c) and at the boundary (d) can be expressed as functions of the material parameters theta . By minimizing the sum of squared residuals of the linear momentum balance along with a sparsity promoting regularization term (e), the thermodynamic potentials (f) are discovered as parsimonious mathematical formulae.","title":"Generalized standard materials"},{"location":"#about-the-documentation","text":"The documentation contains detailed information for the most important functions (subroutines). For each function, the input arguments and output arguments are provided. The documentation can be browsed by using the search box. The provided example helps to understand the workflow of EUCLID, it can be executed using the code and data provided on GitHub . The data used in the publication can be downloaded from the ETH Research Collection .","title":"About the documentation"},{"location":"code_data/","text":"Code All codes are publically available on GitHub . Data Data can be downloaded from the ETH Research Collection .","title":"Code/Data"},{"location":"code_data/#code","text":"All codes are publically available on GitHub .","title":"Code"},{"location":"code_data/#data","text":"Data can be downloaded from the ETH Research Collection .","title":"Data"},{"location":"contact/","text":"Contact Moritz Flaschel E-Mail: mflaschel@ethz.ch Web: compmech.ethz.ch Siddhant Kumar E-Mail: sid.kumar@tudelft.nl Web: mech-mat.com Laura De Lorenzis E-Mail: ldelorenzis@ethz.ch Web: compmech.ethz.ch","title":"Contact"},{"location":"contact/#contact","text":"","title":"Contact"},{"location":"contact/#moritz-flaschel","text":"E-Mail: mflaschel@ethz.ch Web: compmech.ethz.ch","title":"Moritz Flaschel"},{"location":"contact/#siddhant-kumar","text":"E-Mail: sid.kumar@tudelft.nl Web: mech-mat.com","title":"Siddhant Kumar"},{"location":"contact/#laura-de-lorenzis","text":"E-Mail: ldelorenzis@ethz.ch Web: compmech.ethz.ch","title":"Laura De Lorenzis"},{"location":"example_GSM/","text":"Example 2 - Generalized standard materials It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model LEVP. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori. Forward Problem (FEA) We assume the material model LEVP (for which the material parameters can be found in material/lib_VEVPHardMixLin_LEVPHardKinLin.m ) and run the forward finite element simulation (see FEA_rate_dependent_plate_elliptic_holes.m ). The results of the finite element analysis can be found in the ETH Research Collection under 20220907T134236_DATA_lib_VEVPHardMixLin_LEVPHardKinLin_plate_elliptic_holes_noise_1.mat . Inverse Problem (EUCLID)","title":"Example 2"},{"location":"example_GSM/#example-2-generalized-standard-materials","text":"It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model LEVP. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori.","title":"Example 2 - Generalized standard materials"},{"location":"example_GSM/#forward-problem-fea","text":"We assume the material model LEVP (for which the material parameters can be found in material/lib_VEVPHardMixLin_LEVPHardKinLin.m ) and run the forward finite element simulation (see FEA_rate_dependent_plate_elliptic_holes.m ). The results of the finite element analysis can be found in the ETH Research Collection under 20220907T134236_DATA_lib_VEVPHardMixLin_LEVPHardKinLin_plate_elliptic_holes_noise_1.mat .","title":"Forward Problem (FEA)"},{"location":"example_GSM/#inverse-problem-euclid","text":"","title":"Inverse Problem (EUCLID)"},{"location":"example_plasticity/","text":"Example It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model F1. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori. Data and Parameters The input data for EUCLID and the parameters for the optimization process are defined in opt_input.m . First, it is defined whether a Matlab executable file (.mex file) should be used to accelerate the objective function evaluation (see Matlab Coder and MEX File Functions ) and over how many Matlab workers the independent optimization processes should be distributed (see Parallel Computing Toolbox and parfor ). in.use_mex = true; in.n_workers = 24; To consider the data corresponding to material model F1, the variable dataID has to be set to three. dataID = 3; To also consider noise and temporal denoising, we set: in.noise_level = '1'; in.filter = 'sgolay'; in.filter_length = 50; According to these choices the following string is assigned to the variable in.datafile : '20210518T174453_DATA_FYS_1_plate_elliptic_holes_noise_1_sgolay_50' The string contains a timestamp that indicates when the data were generated and contains information about the material model, the geometry, the noise level and the smoothing method, respectively. To load the .mat datafile with the above name, a path has to be added by changing the variable pathname in opt_input.m accordingly. The .mat datafile contains a struct array called data with all information provided by the finite element simulation, such as for example the nodal displacements in data.results.u (see animation below) and net reaction forces in data.results.reaction . Animation 1: Magnitude of displacement obtained from finite element simulations. The displacement is magnified by a factor of 100. In opt_input.m we further define parameters and hyperparameters for the optimization problem. All input information needed for the optimization problem are stored in a struct array called in . Optimization After defining the elementary inputs in opt_input.m , we start the optimization procedure by running opt.m . In opt.m the parameters and the data are loaded and (as mentioned above) stored in the struct arrays in and data , respectively. in = opt_input(); load(in.datafile,'data') Animation 2: Yield surface for different choices of theta . The goal is now to find the unknown material parameters theta , which influence the shape of the plastic yield surface (see animation above) and consequently govern the material behavior. To find the material parameters, an objective function_handle fun_vec is defined. fun_vec = def_objective_vec(in,data); The function_handle takes the material parameters as input and returns a vector, whose sum of squared entries equals the objective function. Note that the function_handle returns a vector instead of a scalar as this is a requirement for using the Matlab build in optimizer lsqnonlin (see below). Taking a closer look at objective_vec.m provides a deeper insight in the internal processes of the objective function calculation. Here, nested loops over all load steps, finite elements and quadrature points are implemented for calculating the internal forces. To this end, the elasto-plastic return mapping algorithm, whose behavior depends on the yield function and hence the material parameters theta , needs to be applied (see local_problem_PlaneStress_notan.m ). For decreasing the computational time needed for the cost function evalution, the function objective_vec.m is converted into a Matlab executable file (.mex file). After defining the objective function we apply a preconditioning optimization by minimizing the objective function with respect to the first material parameter while keeping the other parameters fixed. [theta_init(1), min_cost, ~, ~, ~] = lsqnonlin(fun_vec,theta_init(1),[],[],options); In this way, the approximate size of the yield surface is estimated. Based on the preconditioning solution, multiple random initial guesses are generated and the objective function is minimized for different choices of the hyperparameter lambda_p . The solutions and their corresponding objective function values are stored in a struct array called solution , which is saved as a .mat file with the name: `202106T29085533_RESULTS_lsqnonlin_Pareto_random_par_FYS_1_plate_elliptic_holes_noise_1_sgolay_50` Model Selection As a final postprocessing step, a model with both high parsimony and low cost function value needs to be selected from the generated set of solutions. To this end, selection.m is executed. Here, the hyperparameters for the model selection are chosen as: threshold_factor_C = 1.01; threshold_factor_theta = 5e-3; As solutions were generated based on multiple initial guesses, we choose for every choice of lambda_p the initial guess that corresponds to the lowest objective function value, resulting in one solution for every choice of lambda_p . Afterwards, solutions with cost function values above a threshold are discarded as they are expected to provide low fitting accuracies. From the remaining solutions, the solution with the highest sparsity, i.e., with the lowest regularization term, is selected. Lastly, material parameters below a threshold are discarded. The final solution is: >> selection('202106T29085533_RESULTS_lsqnonlin_Pareto_random_par_FYS_1_plate_elliptic_holes_noise_1_sgolay_50') Selected Solution: 0.2187 0.0220 0 0 0 The algorithm correctly identifies which features have to be active to describe the material behavior and at the same time correctly removes irrelevant features. The correct mathematical form of the material model F1 is identified, however, the material parameter values vary slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Example"},{"location":"example_plasticity/#example","text":"It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model F1. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori.","title":"Example"},{"location":"example_plasticity/#data-and-parameters","text":"The input data for EUCLID and the parameters for the optimization process are defined in opt_input.m . First, it is defined whether a Matlab executable file (.mex file) should be used to accelerate the objective function evaluation (see Matlab Coder and MEX File Functions ) and over how many Matlab workers the independent optimization processes should be distributed (see Parallel Computing Toolbox and parfor ). in.use_mex = true; in.n_workers = 24; To consider the data corresponding to material model F1, the variable dataID has to be set to three. dataID = 3; To also consider noise and temporal denoising, we set: in.noise_level = '1'; in.filter = 'sgolay'; in.filter_length = 50; According to these choices the following string is assigned to the variable in.datafile : '20210518T174453_DATA_FYS_1_plate_elliptic_holes_noise_1_sgolay_50' The string contains a timestamp that indicates when the data were generated and contains information about the material model, the geometry, the noise level and the smoothing method, respectively. To load the .mat datafile with the above name, a path has to be added by changing the variable pathname in opt_input.m accordingly. The .mat datafile contains a struct array called data with all information provided by the finite element simulation, such as for example the nodal displacements in data.results.u (see animation below) and net reaction forces in data.results.reaction . Animation 1: Magnitude of displacement obtained from finite element simulations. The displacement is magnified by a factor of 100. In opt_input.m we further define parameters and hyperparameters for the optimization problem. All input information needed for the optimization problem are stored in a struct array called in .","title":"Data and Parameters"},{"location":"example_plasticity/#optimization","text":"After defining the elementary inputs in opt_input.m , we start the optimization procedure by running opt.m . In opt.m the parameters and the data are loaded and (as mentioned above) stored in the struct arrays in and data , respectively. in = opt_input(); load(in.datafile,'data') Animation 2: Yield surface for different choices of theta . The goal is now to find the unknown material parameters theta , which influence the shape of the plastic yield surface (see animation above) and consequently govern the material behavior. To find the material parameters, an objective function_handle fun_vec is defined. fun_vec = def_objective_vec(in,data); The function_handle takes the material parameters as input and returns a vector, whose sum of squared entries equals the objective function. Note that the function_handle returns a vector instead of a scalar as this is a requirement for using the Matlab build in optimizer lsqnonlin (see below). Taking a closer look at objective_vec.m provides a deeper insight in the internal processes of the objective function calculation. Here, nested loops over all load steps, finite elements and quadrature points are implemented for calculating the internal forces. To this end, the elasto-plastic return mapping algorithm, whose behavior depends on the yield function and hence the material parameters theta , needs to be applied (see local_problem_PlaneStress_notan.m ). For decreasing the computational time needed for the cost function evalution, the function objective_vec.m is converted into a Matlab executable file (.mex file). After defining the objective function we apply a preconditioning optimization by minimizing the objective function with respect to the first material parameter while keeping the other parameters fixed. [theta_init(1), min_cost, ~, ~, ~] = lsqnonlin(fun_vec,theta_init(1),[],[],options); In this way, the approximate size of the yield surface is estimated. Based on the preconditioning solution, multiple random initial guesses are generated and the objective function is minimized for different choices of the hyperparameter lambda_p . The solutions and their corresponding objective function values are stored in a struct array called solution , which is saved as a .mat file with the name: `202106T29085533_RESULTS_lsqnonlin_Pareto_random_par_FYS_1_plate_elliptic_holes_noise_1_sgolay_50`","title":"Optimization"},{"location":"example_plasticity/#model-selection","text":"As a final postprocessing step, a model with both high parsimony and low cost function value needs to be selected from the generated set of solutions. To this end, selection.m is executed. Here, the hyperparameters for the model selection are chosen as: threshold_factor_C = 1.01; threshold_factor_theta = 5e-3; As solutions were generated based on multiple initial guesses, we choose for every choice of lambda_p the initial guess that corresponds to the lowest objective function value, resulting in one solution for every choice of lambda_p . Afterwards, solutions with cost function values above a threshold are discarded as they are expected to provide low fitting accuracies. From the remaining solutions, the solution with the highest sparsity, i.e., with the lowest regularization term, is selected. Lastly, material parameters below a threshold are discarded. The final solution is: >> selection('202106T29085533_RESULTS_lsqnonlin_Pareto_random_par_FYS_1_plate_elliptic_holes_noise_1_sgolay_50') Selected Solution: 0.2187 0.0220 0 0 0 The algorithm correctly identifies which features have to be active to describe the material behavior and at the same time correctly removes irrelevant features. The correct mathematical form of the material model F1 is identified, however, the material parameter values vary slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Model Selection"},{"location":"example_plasticity_w_hardening/","text":"Example 1 - Elastoplasticity It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model F1. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori. Forward Problem (FEA) We assume the material model F1 (for which the material parameters can be found in material/FYS_1_HardMix.m ) and run the forward finite element simulation (see FEA_plate_elliptic_holes.m ). The results of the finite element analysis can be found in the ETH Research Collection under 20211130T010300_DATA_FYS_1_HardMix_plate_elliptic_holes_noise_1.mat . Inverse Problem (EUCLID) Data and Parameters The input data for EUCLID and the parameters for the optimization process are defined in opt_input_HardMix.m . First, it is defined whether a Matlab executable file (.mex file) should be used to accelerate the objective function evaluation (see Matlab Coder and MEX File Functions ) and over how many Matlab workers the independent optimization processes should be distributed (see Parallel Computing Toolbox and parfor ). in.use_mex = true; in.n_workers = 24; To consider the data corresponding to material model F1, the variable dataID has to be set to two. dataID = 2; To also consider noise and temporal denoising, we set: in.noise_level = '1'; in.filter = 'sgolay'; in.filter_length = 50; According to these choices the following string is assigned to the variable in.datafile : '20211130T010300_DATA_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50' The string contains a timestamp that indicates when the data were generated and contains information about the material model, the geometry, the noise level and the smoothing method, respectively. To load the .mat datafile with the above name, a path has to be added by changing the variable pathname in opt_input_HardMix.m accordingly. The .mat datafile contains a struct array called data with all information provided by the finite element simulation, such as for example the nodal displacements in data.results.u (see animation below) and net reaction forces in data.results.reaction . Animation 1: Magnitude of displacement obtained from finite element simulations. The displacement is magnified by a factor of 100. Note that this is an examplary animation, it does not correspond to the data considered in the example. In opt_input_HardMix.m , we further define parameters and hyperparameters for the optimization problem. All input information needed for the optimization problem are stored in a struct array called in . Optimization After defining the elementary inputs in opt_input_HardMix.m , we start the optimization procedure by running opt_HardMix.m . In opt_HardMix.m the parameters and the data are loaded and (as mentioned above) stored in the struct arrays in and data , respectively. in = opt_input_HardMix(); load(in.datafile,'data') Animation 2: Yield surface for different choices of theta . The goal is now to find the unknown material parameters theta and hardening parameters H_isotropic , H_kinematic , which influence the shape of the plastic yield surface (see animation above) and the hardening behavior, respectively. To find the material parameters, an objective function_handle fun_vec is defined. fun_vec = def_objective_vec_HardMixVAF(in,data); The function_handle takes the material parameters as input and returns a vector, whose sum of squared entries equals the objective function. Note that the function_handle returns a vector instead of a scalar as this is a requirement for using the Matlab build in optimizer lsqnonlin (see below). Taking a closer look at objective_vec_HardMixVAF.m provides a deeper insight in the internal processes of the objective function calculation. Here, nested loops over all load steps, finite elements and quadrature points are implemented for calculating the internal forces. To this end, the elasto-plastic return mapping algorithm, whose behavior depends on the yield function and hence the material parameters theta , H_isotropic , H_kinematic , needs to be applied (see local_problem_PlaneStressHardMixVAF_notan.m ). For decreasing the computational time needed for the cost function evalution, the function objective_vec_HardMixVAF.m is converted into a Matlab executable file (.mex file). After defining the objective function we apply a preconditioning optimization by minimizing the objective function with respect to a reduced set of material parameter while keeping the other parameters fixed. In this way, the approximate size of the yield surface is estimated. Based on the preconditioning solution, multiple random initial guesses are generated and the objective function is minimized for different choices of the hyperparameter lambda_p . The solutions and their corresponding objective function values are stored in a struct array called solution , which is saved as a .mat file with the name: `202112T02011118_RESULTS_lsqnonlin_lb_parsplit_HardMixVAF_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50` Model Selection As a final postprocessing step, a model with both high parsimony and low cost function value needs to be selected from the generated set of solutions. To this end, selection_HardMix.m is executed. Here, the hyperparameters for the model selection are chosen as: threshold_factor_cost = 1.01; threshold_factor_parameters = 5e-3; As solutions were generated based on multiple initial guesses, we choose for every choice of lambda_p the initial guess that corresponds to the lowest objective function value, resulting in one solution for every choice of lambda_p . Afterwards, solutions with cost function values above a threshold are discarded as they are expected to provide low fitting accuracies. From the remaining solutions, the solution with the highest sparsity, i.e., with the lowest regularization term, is selected. Lastly, material parameters below a threshold are discarded. The final solution is: >> selection_HardMix('202112T02011118_RESULTS_lsqnonlin_lb_parsplit_HardMixVAF_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50') Selected regularization factor: lambda_p = 256 Selected yield surface parameters: theta = 0.22253 0.019857 0 0 0 0 0 Selected isotropic hardening parameters: H_isotropic = 48.79915 0.5327857 601.8113 Selected kinematic hardening parameters: H_kinematic = 199.8887 928.3547 The algorithm correctly identifies which features have to be active to describe the material behavior and at the same time correctly removes irrelevant features. The correct mathematical form of the material model F1 is identified, however, the material parameter values vary slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Example 1"},{"location":"example_plasticity_w_hardening/#example-1-elastoplasticity","text":"It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to the displacement and net reaction force data that were generated based on the material model F1. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori.","title":"Example 1 - Elastoplasticity"},{"location":"example_plasticity_w_hardening/#forward-problem-fea","text":"We assume the material model F1 (for which the material parameters can be found in material/FYS_1_HardMix.m ) and run the forward finite element simulation (see FEA_plate_elliptic_holes.m ). The results of the finite element analysis can be found in the ETH Research Collection under 20211130T010300_DATA_FYS_1_HardMix_plate_elliptic_holes_noise_1.mat .","title":"Forward Problem (FEA)"},{"location":"example_plasticity_w_hardening/#inverse-problem-euclid","text":"","title":"Inverse Problem (EUCLID)"},{"location":"example_plasticity_w_hardening/#data-and-parameters","text":"The input data for EUCLID and the parameters for the optimization process are defined in opt_input_HardMix.m . First, it is defined whether a Matlab executable file (.mex file) should be used to accelerate the objective function evaluation (see Matlab Coder and MEX File Functions ) and over how many Matlab workers the independent optimization processes should be distributed (see Parallel Computing Toolbox and parfor ). in.use_mex = true; in.n_workers = 24; To consider the data corresponding to material model F1, the variable dataID has to be set to two. dataID = 2; To also consider noise and temporal denoising, we set: in.noise_level = '1'; in.filter = 'sgolay'; in.filter_length = 50; According to these choices the following string is assigned to the variable in.datafile : '20211130T010300_DATA_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50' The string contains a timestamp that indicates when the data were generated and contains information about the material model, the geometry, the noise level and the smoothing method, respectively. To load the .mat datafile with the above name, a path has to be added by changing the variable pathname in opt_input_HardMix.m accordingly. The .mat datafile contains a struct array called data with all information provided by the finite element simulation, such as for example the nodal displacements in data.results.u (see animation below) and net reaction forces in data.results.reaction . Animation 1: Magnitude of displacement obtained from finite element simulations. The displacement is magnified by a factor of 100. Note that this is an examplary animation, it does not correspond to the data considered in the example. In opt_input_HardMix.m , we further define parameters and hyperparameters for the optimization problem. All input information needed for the optimization problem are stored in a struct array called in .","title":"Data and Parameters"},{"location":"example_plasticity_w_hardening/#optimization","text":"After defining the elementary inputs in opt_input_HardMix.m , we start the optimization procedure by running opt_HardMix.m . In opt_HardMix.m the parameters and the data are loaded and (as mentioned above) stored in the struct arrays in and data , respectively. in = opt_input_HardMix(); load(in.datafile,'data') Animation 2: Yield surface for different choices of theta . The goal is now to find the unknown material parameters theta and hardening parameters H_isotropic , H_kinematic , which influence the shape of the plastic yield surface (see animation above) and the hardening behavior, respectively. To find the material parameters, an objective function_handle fun_vec is defined. fun_vec = def_objective_vec_HardMixVAF(in,data); The function_handle takes the material parameters as input and returns a vector, whose sum of squared entries equals the objective function. Note that the function_handle returns a vector instead of a scalar as this is a requirement for using the Matlab build in optimizer lsqnonlin (see below). Taking a closer look at objective_vec_HardMixVAF.m provides a deeper insight in the internal processes of the objective function calculation. Here, nested loops over all load steps, finite elements and quadrature points are implemented for calculating the internal forces. To this end, the elasto-plastic return mapping algorithm, whose behavior depends on the yield function and hence the material parameters theta , H_isotropic , H_kinematic , needs to be applied (see local_problem_PlaneStressHardMixVAF_notan.m ). For decreasing the computational time needed for the cost function evalution, the function objective_vec_HardMixVAF.m is converted into a Matlab executable file (.mex file). After defining the objective function we apply a preconditioning optimization by minimizing the objective function with respect to a reduced set of material parameter while keeping the other parameters fixed. In this way, the approximate size of the yield surface is estimated. Based on the preconditioning solution, multiple random initial guesses are generated and the objective function is minimized for different choices of the hyperparameter lambda_p . The solutions and their corresponding objective function values are stored in a struct array called solution , which is saved as a .mat file with the name: `202112T02011118_RESULTS_lsqnonlin_lb_parsplit_HardMixVAF_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50`","title":"Optimization"},{"location":"example_plasticity_w_hardening/#model-selection","text":"As a final postprocessing step, a model with both high parsimony and low cost function value needs to be selected from the generated set of solutions. To this end, selection_HardMix.m is executed. Here, the hyperparameters for the model selection are chosen as: threshold_factor_cost = 1.01; threshold_factor_parameters = 5e-3; As solutions were generated based on multiple initial guesses, we choose for every choice of lambda_p the initial guess that corresponds to the lowest objective function value, resulting in one solution for every choice of lambda_p . Afterwards, solutions with cost function values above a threshold are discarded as they are expected to provide low fitting accuracies. From the remaining solutions, the solution with the highest sparsity, i.e., with the lowest regularization term, is selected. Lastly, material parameters below a threshold are discarded. The final solution is: >> selection_HardMix('202112T02011118_RESULTS_lsqnonlin_lb_parsplit_HardMixVAF_FYS_1_HardMix_plate_elliptic_holes_noise_1_sgolay_50') Selected regularization factor: lambda_p = 256 Selected yield surface parameters: theta = 0.22253 0.019857 0 0 0 0 0 Selected isotropic hardening parameters: H_isotropic = 48.79915 0.5327857 601.8113 Selected kinematic hardening parameters: H_kinematic = 199.8887 928.3547 The algorithm correctly identifies which features have to be active to describe the material behavior and at the same time correctly removes irrelevant features. The correct mathematical form of the material model F1 is identified, however, the material parameter values vary slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Model Selection"},{"location":"notation/","text":"Notation Abbreviations Abbreviation Meaning bc boundary condition dof degree of freedom FD finite differences FEA finite element analysis FEM finite element method FYS Fourier expansion based yield surface GP Gauss point HardIsoLin linear isotropic hardening HardIsoNonlin nonlinear isotropic hardening HardKinLin linear kinematic hardening HardMix mixed isotropic and kinematic hardening HardMixLin linear mixed isotropic and kinematic hardening notan no elasto-plastic consistent tangent modulus computation NR Newton-Raphson mex MATLAB executable opt optimization (inverse problem) UT uniaxial tension UTC uniaxial tension followed by uniaxial compression VAF Voce and Armstrong-Frederick hardening VEVP viscoelastic-viscoplastic Variables Variable Meaning C stiffness matrix CPlaneStress stiffness matrix under plane stress CC elasto-plastic consistent tangent modulus epsilonV strain in Voigt notation epsilonVp plastic strain in Voigt notation epsilonVp_prev plastic strain at previous time/load step in Voigt notation fun objective function fun_vec objective function components gathered in a vector in input parameters S compliance matrix SPlaneStress compliance matrix under plane stress sigmaV stress in Voigt notation","title":"Notation"},{"location":"notation/#notation","text":"","title":"Notation"},{"location":"notation/#abbreviations","text":"Abbreviation Meaning bc boundary condition dof degree of freedom FD finite differences FEA finite element analysis FEM finite element method FYS Fourier expansion based yield surface GP Gauss point HardIsoLin linear isotropic hardening HardIsoNonlin nonlinear isotropic hardening HardKinLin linear kinematic hardening HardMix mixed isotropic and kinematic hardening HardMixLin linear mixed isotropic and kinematic hardening notan no elasto-plastic consistent tangent modulus computation NR Newton-Raphson mex MATLAB executable opt optimization (inverse problem) UT uniaxial tension UTC uniaxial tension followed by uniaxial compression VAF Voce and Armstrong-Frederick hardening VEVP viscoelastic-viscoplastic","title":"Abbreviations"},{"location":"notation/#variables","text":"Variable Meaning C stiffness matrix CPlaneStress stiffness matrix under plane stress CC elasto-plastic consistent tangent modulus epsilonV strain in Voigt notation epsilonVp plastic strain in Voigt notation epsilonVp_prev plastic strain at previous time/load step in Voigt notation fun objective function fun_vec objective function components gathered in a vector in input parameters S compliance matrix SPlaneStress compliance matrix under plane stress sigmaV stress in Voigt notation","title":"Variables"},{"location":"publication/","text":"Elastoplasticity This browser does not support PDFs. Please download the PDF to view it: Download PDF . Generalized standard materials This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Publications"},{"location":"publication/#elastoplasticity","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Elastoplasticity"},{"location":"publication/#generalized-standard-materials","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Generalized standard materials"},{"location":"code/FEA_plate_elliptic_holes/","text":"FEA_PLATE_ELLIPTIC_HOLES - executes a finite element analysis Comments Finite element data is saved as a structural array. The material, mesh and boundary conditions have to be specified by the user. Set testcase = true and material = vonMises for a computationally inexpensive example. Assumptions: two-dimensional plane stress no body force only homogeneous Neumann boundary conditions displacement control Input Arguments none Output Arguments none","title":"FEA_plate_elliptic_holes"},{"location":"code/FEA_plate_elliptic_holes/#fea_plate_elliptic_holes-executes-a-finite-element-analysis","text":"","title":"FEA_PLATE_ELLIPTIC_HOLES - executes a finite element analysis"},{"location":"code/FEA_plate_elliptic_holes/#comments","text":"Finite element data is saved as a structural array. The material, mesh and boundary conditions have to be specified by the user. Set testcase = true and material = vonMises for a computationally inexpensive example. Assumptions: two-dimensional plane stress no body force only homogeneous Neumann boundary conditions displacement control","title":"Comments"},{"location":"code/FEA_plate_elliptic_holes/#input-arguments","text":"none","title":"Input Arguments"},{"location":"code/FEA_plate_elliptic_holes/#output-arguments","text":"none","title":"Output Arguments"},{"location":"code/FEA_rate_dependent_plate_elliptic_holes/","text":"FEA_RATE_DEPENDENT_PLATE_ELLIPTIC_HOLES - executes a rate-dependent finite element analysis Comments Finite element data is saved as a structural array. The material, mesh and boundary conditions have to be specified by the user. Set testcase = true and material = lib_VEVPHardMixLin_LEVPHardKinLin for a computationally inexpensive example. Assumptions: two-dimensional plane strain no body force only homogeneous Neumann boundary conditions displacement control Input Arguments none Output Arguments none","title":"FEA_rate_dependent_plate_elliptic_holes"},{"location":"code/FEA_rate_dependent_plate_elliptic_holes/#fea_rate_dependent_plate_elliptic_holes-executes-a-rate-dependent-finite-element-analysis","text":"","title":"FEA_RATE_DEPENDENT_PLATE_ELLIPTIC_HOLES - executes a rate-dependent finite element analysis"},{"location":"code/FEA_rate_dependent_plate_elliptic_holes/#comments","text":"Finite element data is saved as a structural array. The material, mesh and boundary conditions have to be specified by the user. Set testcase = true and material = lib_VEVPHardMixLin_LEVPHardKinLin for a computationally inexpensive example. Assumptions: two-dimensional plane strain no body force only homogeneous Neumann boundary conditions displacement control","title":"Comments"},{"location":"code/FEA_rate_dependent_plate_elliptic_holes/#input-arguments","text":"none","title":"Input Arguments"},{"location":"code/FEA_rate_dependent_plate_elliptic_holes/#output-arguments","text":"none","title":"Output Arguments"},{"location":"code/V2dev/","text":"V2DEV - calculates the deviatoric stress from the Cauchy stress vector (Voigt)","title":"V2dev"},{"location":"code/V2dev/#v2dev-calculates-the-deviatoric-stress-from-the-cauchy-stress-vector-voigt","text":"","title":"V2DEV - calculates the deviatoric stress from the Cauchy stress vector (Voigt)"},{"location":"code/V2eq/","text":"V2EQ - calculates the equivalent stress from the Cauchy stress vector (Voigt)","title":"V2eq"},{"location":"code/V2eq/#v2eq-calculates-the-equivalent-stress-from-the-cauchy-stress-vector-voigt","text":"","title":"V2EQ - calculates the equivalent stress from the Cauchy stress vector (Voigt)"},{"location":"code/def_objective_vec_HardMixVAF/","text":"DEF_OBJECTIVE_VEC_HARDMIXVAF - creates an objective function handle Comments This function creates an objective function handle. The function handle takes the material parameters as input. Note that the function handle does not return a scalar but a vector. The Matlab build-in optimizer (e.g., lsqnonlin) minimizes the sum of squared entries of this vector. A Matlab executable file (.mex file) may be used to accelerate the objective function evaluation. Input Arguments in ( struct ) - see opt_input documentation data ( struct ) - FEM data data.results.u ( double ) - displacement data for every load step (every column corresponds to one load step) data.results.reaction ( double ) - reaction force data for every load step data.algorithm.n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) data.algorithm.tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) data.mesh.n_dof ( double ) - number of degrees of freedom in the mesh data.mesh.dof ( double ) - degrees of freedom data.mesh.n_element ( double ) - number of finite elements in the mesh data.mesh.n_dof_per_element ( double ) - number of degrees of freedom per finite element data.mesh.element_dof ( double ) - degrees of freedom at each finite element element (each row provides all degrees of freedom at the corresponding finite element) data.mesh.Gauss_weights ( double ) - Gaussian quadrature weights data.mesh.n_Gauss_per_dim ( double ) - number of Gauss points per dimension data.mesh.detJ_GP ( double ) - determinant of the Jacobian at each Gauss point needed for mapping integrals between the reference and physical finite element data.mesh.B_GP ( double ) - help matrix at each Gauss point needed for calculating shape function derivatives data.bc.dof_fix ( double ) - fixed degrees of freedom data.bc.dof_displacement ( double ) - free degrees of freedom data.bc.dof_reaction ( double ) - degrees of freedom corresponding to reaction forces Output Arguments fun_vec ( function_handle ) - objective function handle","title":"def_objective_vec_HardMixVAF"},{"location":"code/def_objective_vec_HardMixVAF/#def_objective_vec_hardmixvaf-creates-an-objective-function-handle","text":"","title":"DEF_OBJECTIVE_VEC_HARDMIXVAF - creates an objective function handle"},{"location":"code/def_objective_vec_HardMixVAF/#comments","text":"This function creates an objective function handle. The function handle takes the material parameters as input. Note that the function handle does not return a scalar but a vector. The Matlab build-in optimizer (e.g., lsqnonlin) minimizes the sum of squared entries of this vector. A Matlab executable file (.mex file) may be used to accelerate the objective function evaluation.","title":"Comments"},{"location":"code/def_objective_vec_HardMixVAF/#input-arguments","text":"in ( struct ) - see opt_input documentation data ( struct ) - FEM data data.results.u ( double ) - displacement data for every load step (every column corresponds to one load step) data.results.reaction ( double ) - reaction force data for every load step data.algorithm.n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) data.algorithm.tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) data.mesh.n_dof ( double ) - number of degrees of freedom in the mesh data.mesh.dof ( double ) - degrees of freedom data.mesh.n_element ( double ) - number of finite elements in the mesh data.mesh.n_dof_per_element ( double ) - number of degrees of freedom per finite element data.mesh.element_dof ( double ) - degrees of freedom at each finite element element (each row provides all degrees of freedom at the corresponding finite element) data.mesh.Gauss_weights ( double ) - Gaussian quadrature weights data.mesh.n_Gauss_per_dim ( double ) - number of Gauss points per dimension data.mesh.detJ_GP ( double ) - determinant of the Jacobian at each Gauss point needed for mapping integrals between the reference and physical finite element data.mesh.B_GP ( double ) - help matrix at each Gauss point needed for calculating shape function derivatives data.bc.dof_fix ( double ) - fixed degrees of freedom data.bc.dof_displacement ( double ) - free degrees of freedom data.bc.dof_reaction ( double ) - degrees of freedom corresponding to reaction forces","title":"Input Arguments"},{"location":"code/def_objective_vec_HardMixVAF/#output-arguments","text":"fun_vec ( function_handle ) - objective function handle","title":"Output Arguments"},{"location":"code/engineering2ordinary_strainV/","text":"ENGINEERING2ORDINARY_STRAINV - provides a matrix that transforms engineering strains to ordinary strains in Voigt notation Comments It is epsilonV_ordinary = IV_eng * epsilonV_engineering . epsilonV_ordinary is a vector containing the strain components in Voigt notation without a factor of two in front of the shear components. epsilonV_engineering is a vector containing the strain components in Voigt notation with a factor of two in front of the shear components. Assumptions: Voigt notation Input Arguments dim ( double ) - dimension (default: 3) Output Arguments IV_eng ( double ) - matrix such that epsilonV_ordinary = IV_eng * epsilonV_engineering","title":"engineering2ordinary_strainV"},{"location":"code/engineering2ordinary_strainV/#engineering2ordinary_strainv-provides-a-matrix-that-transforms-engineering-strains-to-ordinary-strains-in-voigt-notation","text":"","title":"ENGINEERING2ORDINARY_STRAINV - provides a matrix that transforms engineering strains to ordinary strains in Voigt notation"},{"location":"code/engineering2ordinary_strainV/#comments","text":"It is epsilonV_ordinary = IV_eng * epsilonV_engineering . epsilonV_ordinary is a vector containing the strain components in Voigt notation without a factor of two in front of the shear components. epsilonV_engineering is a vector containing the strain components in Voigt notation with a factor of two in front of the shear components. Assumptions: Voigt notation","title":"Comments"},{"location":"code/engineering2ordinary_strainV/#input-arguments","text":"dim ( double ) - dimension (default: 3)","title":"Input Arguments"},{"location":"code/engineering2ordinary_strainV/#output-arguments","text":"IV_eng ( double ) - matrix such that epsilonV_ordinary = IV_eng * epsilonV_engineering","title":"Output Arguments"},{"location":"code/get_CCFD_PlaneStressHardMixVAF/","text":"GET_CCFD_PLANESTRESSHARDMIXVAF - computes the consistent tangent modulus using finite differences","title":"get_CCFD_PlaneStressHardMixVAF"},{"location":"code/get_CCFD_PlaneStressHardMixVAF/#get_ccfd_planestresshardmixvaf-computes-the-consistent-tangent-modulus-using-finite-differences","text":"","title":"GET_CCFD_PLANESTRESSHARDMIXVAF - computes the consistent tangent modulus using finite differences"},{"location":"code/get_CCFD_VEVPHardMixLin/","text":"GET_CCFD_VEVPHARDMIXLIN - computes the consistent tangent modulus using finite differences","title":"get_CCFD_VEVPHardMixLin"},{"location":"code/get_CCFD_VEVPHardMixLin/#get_ccfd_vevphardmixlin-computes-the-consistent-tangent-modulus-using-finite-differences","text":"","title":"GET_CCFD_VEVPHARDMIXLIN - computes the consistent tangent modulus using finite differences"},{"location":"code/get_df_PlaneStressHardMixVAF/","text":"GET_DF_PLANESTRESSHARDMIXVAF - evaluates the yield function and its derivatives Comments Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_12) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress Output Arguments yield function value and derivatives of the yield function","title":"get_df_PlaneStressHardMixVAF"},{"location":"code/get_df_PlaneStressHardMixVAF/#get_df_planestresshardmixvaf-evaluates-the-yield-function-and-its-derivatives","text":"","title":"GET_DF_PLANESTRESSHARDMIXVAF - evaluates the yield function and its derivatives"},{"location":"code/get_df_PlaneStressHardMixVAF/#comments","text":"Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/get_df_PlaneStressHardMixVAF/#input-arguments","text":"theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_12) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress","title":"Input Arguments"},{"location":"code/get_df_PlaneStressHardMixVAF/#output-arguments","text":"yield function value and derivatives of the yield function","title":"Output Arguments"},{"location":"code/get_df_PlaneStressHardMixVAF_FD/","text":"GET_DF_PLANESTRESSHARDMIXVAF_FD - evaluates the yield function and its derivatives using finite differences Comments Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_12) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress FD ( double ) - finite differences stepsize secondDerivative ( double ) - indicates whether second derivative should be computed Output Arguments derivatives of the yield function","title":"get_df_PlaneStressHardMixVAF_FD"},{"location":"code/get_df_PlaneStressHardMixVAF_FD/#get_df_planestresshardmixvaf_fd-evaluates-the-yield-function-and-its-derivatives-using-finite-differences","text":"","title":"GET_DF_PLANESTRESSHARDMIXVAF_FD - evaluates the yield function and its derivatives using finite differences"},{"location":"code/get_df_PlaneStressHardMixVAF_FD/#comments","text":"Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/get_df_PlaneStressHardMixVAF_FD/#input-arguments","text":"theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_12) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress FD ( double ) - finite differences stepsize secondDerivative ( double ) - indicates whether second derivative should be computed","title":"Input Arguments"},{"location":"code/get_df_PlaneStressHardMixVAF_FD/#output-arguments","text":"derivatives of the yield function","title":"Output Arguments"},{"location":"code/get_f_PlaneStressHardMixVAF/","text":"GET_F_PLANESTRESSHARDMIXVAF - evaluates the yield function Comments Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_22) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress Output Arguments f ( double ) - value of the yield function","title":"get_f_PlaneStressHardMixVAF"},{"location":"code/get_f_PlaneStressHardMixVAF/#get_f_planestresshardmixvaf-evaluates-the-yield-function","text":"","title":"GET_F_PLANESTRESSHARDMIXVAF - evaluates the yield function"},{"location":"code/get_f_PlaneStressHardMixVAF/#comments","text":"Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/get_f_PlaneStressHardMixVAF/#input-arguments","text":"theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters sigmaV ( double ) - Cauchy stress under plane stress conditions in Voigt notation (sigma_11, sigma_22, sigma_22) gamma ( double ) - plastic multiplier sigmaV_back ( double ) - back stress","title":"Input Arguments"},{"location":"code/get_f_PlaneStressHardMixVAF/#output-arguments","text":"f ( double ) - value of the yield function","title":"Output Arguments"},{"location":"code/global_problem_PlaneStrain_VEVPHardMixLin/","text":"","title":"global problem PlaneStrain VEVPHardMixLin"},{"location":"code/global_problem_PlaneStressHardMixVAF/","text":"GLOBAL_PROBLEM_PLANESTRESSHARDMIXVAF - solves the global finite element problem Comments This function solves the global finite element problem, i.e., the residuals of the discretized weak formulation are minimized. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments n_save_YieldSurface ( double ) - n_NR_global ( double ) - maximum number of Newton-Raphson iterations used for solving the global problem tol_NR_global ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the global problem n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters n_dof ( double ) - see mesh_info n_element ( double ) - see mesh_info n_dof_per_element ( double ) - see mesh_info element_dof ( double ) - see mesh_info Gauss_weights ( double ) - see mesh_info n_Gauss_per_dim ( double ) - see mesh_info detJ_GP ( double ) - see mesh_info B_GP ( double ) - see mesh_info dof_fix ( double ) - fixed degrees of freedom dof_displacement ( double ) - degrees of freedom under displacement control dof_reaction ( double ) - degrees of freedom associated with the reaction forces max_displacement ( double ) - maximum applied displacement n_step ( double ) - number of load steps displacement_increment ( double ) - applied displacement increment Output Arguments u ( double ) - displacement at each node for each load step reaction ( double ) - reaction forces for each load step epsilonVp_GP ( double ) - plastic component of the infinitesimal strain at each Gauss point for the last load step gamma_GP ( double ) - plastic multiplier at each Gauss point for the last load step sigmaV_back_GP ( double ) - back stress at each Gauss point for the last load step YieldSurface ( double ) - stresses at which yielding has occured","title":"global_problem_PlaneStressHardMixVAF"},{"location":"code/global_problem_PlaneStressHardMixVAF/#global_problem_planestresshardmixvaf-solves-the-global-finite-element-problem","text":"","title":"GLOBAL_PROBLEM_PLANESTRESSHARDMIXVAF - solves the global finite element problem"},{"location":"code/global_problem_PlaneStressHardMixVAF/#comments","text":"This function solves the global finite element problem, i.e., the residuals of the discretized weak formulation are minimized. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/global_problem_PlaneStressHardMixVAF/#input-arguments","text":"n_save_YieldSurface ( double ) - n_NR_global ( double ) - maximum number of Newton-Raphson iterations used for solving the global problem tol_NR_global ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the global problem n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters n_dof ( double ) - see mesh_info n_element ( double ) - see mesh_info n_dof_per_element ( double ) - see mesh_info element_dof ( double ) - see mesh_info Gauss_weights ( double ) - see mesh_info n_Gauss_per_dim ( double ) - see mesh_info detJ_GP ( double ) - see mesh_info B_GP ( double ) - see mesh_info dof_fix ( double ) - fixed degrees of freedom dof_displacement ( double ) - degrees of freedom under displacement control dof_reaction ( double ) - degrees of freedom associated with the reaction forces max_displacement ( double ) - maximum applied displacement n_step ( double ) - number of load steps displacement_increment ( double ) - applied displacement increment","title":"Input Arguments"},{"location":"code/global_problem_PlaneStressHardMixVAF/#output-arguments","text":"u ( double ) - displacement at each node for each load step reaction ( double ) - reaction forces for each load step epsilonVp_GP ( double ) - plastic component of the infinitesimal strain at each Gauss point for the last load step gamma_GP ( double ) - plastic multiplier at each Gauss point for the last load step sigmaV_back_GP ( double ) - back stress at each Gauss point for the last load step YieldSurface ( double ) - stresses at which yielding has occured","title":"Output Arguments"},{"location":"code/global_problem_call/","text":"GLOBAL_PROBLEM_CALL - executes the finite element analysis Comments In this function, the finite element analysis is executed. Dependent on the type of material (e.g., type of hardening), different finite element solvers are called. Input Arguments algorithm ( struct ) - structural array containing information needed for the algorithm material ( struct ) - structural array containing material information mesh ( struct ) - structural array containing information about the finite element mesh bc ( struct ) - structural array containing information about the boundary conditions Output Arguments results ( struct ) - structural array containing finite element results","title":"global_problem_call"},{"location":"code/global_problem_call/#global_problem_call-executes-the-finite-element-analysis","text":"","title":"GLOBAL_PROBLEM_CALL - executes the finite element analysis"},{"location":"code/global_problem_call/#comments","text":"In this function, the finite element analysis is executed. Dependent on the type of material (e.g., type of hardening), different finite element solvers are called.","title":"Comments"},{"location":"code/global_problem_call/#input-arguments","text":"algorithm ( struct ) - structural array containing information needed for the algorithm material ( struct ) - structural array containing material information mesh ( struct ) - structural array containing information about the finite element mesh bc ( struct ) - structural array containing information about the boundary conditions","title":"Input Arguments"},{"location":"code/global_problem_call/#output-arguments","text":"results ( struct ) - structural array containing finite element results","title":"Output Arguments"},{"location":"code/identityV/","text":"IDENTITY - transforms the identity tensor from matrix to vector (Voigt) representation Comments Assumptions: Voigt notation Input Arguments dim ( double ) - dimension (default: 3) Output Arguments IV ( double ) - identity tensor as a vector in Voigt notation","title":"identityV"},{"location":"code/identityV/#identity-transforms-the-identity-tensor-from-matrix-to-vector-voigt-representation","text":"","title":"IDENTITY - transforms the identity tensor from matrix to vector (Voigt) representation"},{"location":"code/identityV/#comments","text":"Assumptions: Voigt notation","title":"Comments"},{"location":"code/identityV/#input-arguments","text":"dim ( double ) - dimension (default: 3)","title":"Input Arguments"},{"location":"code/identityV/#output-arguments","text":"IV ( double ) - identity tensor as a vector in Voigt notation","title":"Output Arguments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin/","text":"LOCAL_PROBLEM_PLANESTRAIN_VEVPHARDMIXLIN - solves the local problem Comments This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2 Input Arguments Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) CC ( double ) - consistent tangent modulus alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged","title":"local_problem_PlaneStrain_VEVPHardMixLin"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin/#local_problem_planestrain_vevphardmixlin-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_PLANESTRAIN_VEVPHARDMIXLIN - solves the local problem"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin/#comments","text":"This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2","title":"Comments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin/#input-arguments","text":"Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) CC ( double ) - consistent tangent modulus alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged","title":"Output Arguments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin_notan/","text":"LOCAL_PROBLEM_PLANESTRAIN_VEVPHARDMIXLIN_NOTAN - solves the local problem Comments This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note that it is not required to compute the consistent tangent modulus in the inverse problem. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2 Input Arguments Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged","title":"local_problem_PlaneStrain_VEVPHardMixLin_notan"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin_notan/#local_problem_planestrain_vevphardmixlin_notan-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_PLANESTRAIN_VEVPHARDMIXLIN_NOTAN - solves the local problem"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin_notan/#comments","text":"This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note that it is not required to compute the consistent tangent modulus in the inverse problem. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2","title":"Comments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin_notan/#input-arguments","text":"Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_PlaneStrain_VEVPHardMixLin_notan/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged","title":"Output Arguments"},{"location":"code/local_problem_PlaneStressHardMixVAF/","text":"LOCAL_PROBLEM_PLANESTRESSHARDMIXVAF - solves the local problem Comments This function solves the local problem, i.e., the elastic predictor-plastic corrector return mapping algorithm. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters epsilonV ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) epsilonVp_prev ( double ) - plastic component of the infinitesimal strain at the previous load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma_prev ( double ) - plastic multiplier at the previous load step sigmaV_back_prev ( double ) - back stress at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) CC ( double ) - consistent tangent modulus epsilonVp ( double ) - plastic component of the infinitesimal strain at the current load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) elastic ( logical ) - indicates whether the load step was purely elastic gamma ( double ) - plastic multiplier at the current load step sigma_back ( double ) - back stress at the current load step converged_local ( logical ) - indicates whether the local problem converged","title":"local_problem_PlaneStressHardMixVAF"},{"location":"code/local_problem_PlaneStressHardMixVAF/#local_problem_planestresshardmixvaf-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_PLANESTRESSHARDMIXVAF - solves the local problem"},{"location":"code/local_problem_PlaneStressHardMixVAF/#comments","text":"This function solves the local problem, i.e., the elastic predictor-plastic corrector return mapping algorithm. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/local_problem_PlaneStressHardMixVAF/#input-arguments","text":"n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters epsilonV ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) epsilonVp_prev ( double ) - plastic component of the infinitesimal strain at the previous load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma_prev ( double ) - plastic multiplier at the previous load step sigmaV_back_prev ( double ) - back stress at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_PlaneStressHardMixVAF/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) CC ( double ) - consistent tangent modulus epsilonVp ( double ) - plastic component of the infinitesimal strain at the current load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) elastic ( logical ) - indicates whether the load step was purely elastic gamma ( double ) - plastic multiplier at the current load step sigma_back ( double ) - back stress at the current load step converged_local ( logical ) - indicates whether the local problem converged","title":"Output Arguments"},{"location":"code/local_problem_PlaneStressHardMixVAF_notan/","text":"LOCAL_PROBLEM_PLANESTRESSHARDMIXVAF_NOTAN - solves the local problem Comments This function solves the local problem, i.e., the elastic predictor-plastic corrector return mapping algorithm. Note that it is not required to compute the elasto-plastic consistent tangent modulus in the inverse problem. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters epsilonV ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) epsilonVp_prev ( double ) - plastic component of the infinitesimal strain at the previous load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma_prev ( double ) - plastic multiplier at the previous load step sigmaV_back_prev ( double ) - back stress at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) epsilonVp ( double ) - plastic component of the infinitesimal strain at the current load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma ( double ) - plastic multiplier at the current load step sigma_back ( double ) - back stress at the current load step converged_local ( logical ) - indicates whether the local problem converged","title":"local_problem_PlaneStressHardMixVAF_notan"},{"location":"code/local_problem_PlaneStressHardMixVAF_notan/#local_problem_planestresshardmixvaf_notan-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_PLANESTRESSHARDMIXVAF_NOTAN - solves the local problem"},{"location":"code/local_problem_PlaneStressHardMixVAF_notan/#comments","text":"This function solves the local problem, i.e., the elastic predictor-plastic corrector return mapping algorithm. Note that it is not required to compute the elasto-plastic consistent tangent modulus in the inverse problem. Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/local_problem_PlaneStressHardMixVAF_notan/#input-arguments","text":"n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - elastic properties (stiffness matrix) SPlaneStress ( double ) - elastic properties (compliance matrix) theta ( double ) - material parameters H_isotropic ( double ) - isotropic hardening parameters H_kinematic ( double ) - kinematic hardening parameters epsilonV ( double ) - infinitesimal strain at the current load step in Voigt notation (epsilon_11, epsilon_22, 2*epsilon_12) epsilonVp_prev ( double ) - plastic component of the infinitesimal strain at the previous load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma_prev ( double ) - plastic multiplier at the previous load step sigmaV_back_prev ( double ) - back stress at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_PlaneStressHardMixVAF_notan/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation (sigma_11, sigma_22, sigma_12) epsilonVp ( double ) - plastic component of the infinitesimal strain at the current load step in Voigt notation (epsilon_p_11, epsilon_p_22, 2*epsilon_p_12, epsilon_p_33) gamma ( double ) - plastic multiplier at the current load step sigma_back ( double ) - back stress at the current load step converged_local ( logical ) - indicates whether the local problem converged","title":"Output Arguments"},{"location":"code/local_problem_VEVPHardMixLin/","text":"LOCAL_PROBLEM_VEVPHARDMIXLIN - solves the local problem Comments This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2 Input Arguments Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation CC ( double ) - consistent tangent modulus alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged caution: this implementation assumes gi > 0 and ki > 0","title":"local_problem_VEVPHardMixLin"},{"location":"code/local_problem_VEVPHardMixLin/#local_problem_vevphardmixlin-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_VEVPHARDMIXLIN - solves the local problem"},{"location":"code/local_problem_VEVPHardMixLin/#comments","text":"This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2","title":"Comments"},{"location":"code/local_problem_VEVPHardMixLin/#input-arguments","text":"Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_VEVPHardMixLin/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation CC ( double ) - consistent tangent modulus alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged caution: this implementation assumes gi > 0 and ki > 0","title":"Output Arguments"},{"location":"code/local_problem_VEVPHardMixLin_notan/","text":"LOCAL_PROBLEM_VEVPHARDMIXLIN_NOTAN - solves the local problem Comments This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note that it is not required to compute the consistent tangent modulus in the inverse problem. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2 Input Arguments Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step Output Arguments sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged caution: this implementation assumes gi > 0 and ki > 0","title":"local_problem_VEVPHardMixLin_notan"},{"location":"code/local_problem_VEVPHardMixLin_notan/#local_problem_vevphardmixlin_notan-solves-the-local-problem","text":"","title":"LOCAL_PROBLEM_VEVPHARDMIXLIN_NOTAN - solves the local problem"},{"location":"code/local_problem_VEVPHardMixLin_notan/#comments","text":"This function solves the local problem, i.e., the viscoelastic-viscoplastic constitutive equations with mixed isotropic and kinematic hardening. Note that it is not required to compute the consistent tangent modulus in the inverse problem. Note: epsilon_vp = alpha_1 = alpha_3 gamma = sqrt(3/2) * alpha_2","title":"Comments"},{"location":"code/local_problem_VEVPHardMixLin_notan/#input-arguments","text":"Gi ( double ) - viscoelastic material parameters gi ( double ) - viscoelastic material parameters Ki ( double ) - viscoelastic material parameters ki ( double ) - viscoelastic material parameters Ginf ( double ) - viscoelastic material parameter Kinf ( double ) - viscoelastic material parameter H_iso ( double ) - isotropic hardening parameter H_kin ( double ) - kinematic hardening parameter eta ( double ) - viscoplastic material parameter sigma_0 ( double ) - yield stress time_inc ( double ) - time increment epsilonV_2DPlaneStrain ( double ) - infinitesimal strain at the current load step in Voigt notation alphaV_prev ( double ) - viscoelastic internal variables at the previous load step epsilonVvp_prev ( double ) - viscoplastic internal variables at the previous load step gamma_prev ( double ) - plastic multiplier at the previous load step","title":"Input Arguments"},{"location":"code/local_problem_VEVPHardMixLin_notan/#output-arguments","text":"sigmaV ( double ) - Cauchy stress at the current load step in Voigt notation alphaV ( double ) - viscoelastic internal variables at the current load step epsilonVvp ( double ) - viscoplastic internal variables at the current load step gamma ( double ) - plastic multiplier at the current load step viscoelastic ( logical ) - indicates whether the load step was purely viscoelastic converged_local ( logical ) - indicates whether the local problem converged caution: this implementation assumes gi > 0 and ki > 0","title":"Output Arguments"},{"location":"code/mesh_info/","text":"MESH_INFO - generates important information for a given finite element mesh Comments Given a finite element mesh, this function computes information such as the number of degrees of freedom, the number of elements, the Jacobian of the mapping between physical and reference element, the shape function derivatives etc.. Input Arguments mesh ( struct ) - structural array containing information about the finite element mesh Output Arguments mesh ( struct ) - structural array containing information about the finite element mesh such as for example the determinant of the Jacobian mesh.detJ_GP and the shape function derivatives mesh.B_GP at each Gauss point","title":"mesh_info"},{"location":"code/mesh_info/#mesh_info-generates-important-information-for-a-given-finite-element-mesh","text":"","title":"MESH_INFO - generates important information for a given finite element mesh"},{"location":"code/mesh_info/#comments","text":"Given a finite element mesh, this function computes information such as the number of degrees of freedom, the number of elements, the Jacobian of the mapping between physical and reference element, the shape function derivatives etc..","title":"Comments"},{"location":"code/mesh_info/#input-arguments","text":"mesh ( struct ) - structural array containing information about the finite element mesh","title":"Input Arguments"},{"location":"code/mesh_info/#output-arguments","text":"mesh ( struct ) - structural array containing information about the finite element mesh such as for example the determinant of the Jacobian mesh.detJ_GP and the shape function derivatives mesh.B_GP at each Gauss point","title":"Output Arguments"},{"location":"code/objective_vec_HardMixVAF/","text":"OBJECTIVE_VEC_HARDMIXVAF - calculates the objective minimization function Comments This function defines the objective function that depends on the given data and on theta. Note that the function does not return a scalar but a vector. The Matlab build-in optimizer (e.g., lsqnonlin) minimizes the sum of squared entries of this vector. This function may be converted into a Matlab executable file (.mex file) with the Matlab Coder to accelerate the objective function evaluation. Input Arguments paramters ( double ) - material parameters q_case ( double ) - see opt_input documentation q ( double ) - see opt_input documentation lambda_r ( double ) - see opt_input documentation lambda_p ( double ) - see opt_input documentation p ( double ) - see opt_input documentation n_eval ( double ) - see opt_input documentation u ( double ) - displacement data for every load step (every column corresponds to one load step) reaction ( double ) - reaction force data for every load step n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - known elastic properties (stiffness matrix) SPlaneStress ( double ) - known elastic properties (compliance matrix) n_dof ( double ) - number of degrees of freedom in the mesh n_element ( double ) - number of finite elements in the mesh n_dof_per_element ( double ) - number of degrees of freedom per finite element element_dof ( double ) - degrees of freedom at each finite element element (each row provides all degrees of freedom at the corresponding finite element) Gauss_weights ( double ) - Gaussian quadrature weights n_Gauss_per_dim ( double ) - number of Gauss points per dimension detJ_GP ( double ) - determinant of the Jacobian at each Gauss point needed for mapping integrals between the reference and physical finite element B_GP ( double ) - help matrix at each Gauss point needed for calculating shape function derivatives dof_free ( double ) - free degrees of freedom dof_reaction ( double ) - degrees of freedom corresponding to reaction forces Output Arguments cost ( double ) - vector, whose sum of squared entries must be minimized (note that the regularization term is included as the last entry of this vector)","title":"objective_vec_HardMixVAF"},{"location":"code/objective_vec_HardMixVAF/#objective_vec_hardmixvaf-calculates-the-objective-minimization-function","text":"","title":"OBJECTIVE_VEC_HARDMIXVAF - calculates the objective minimization function"},{"location":"code/objective_vec_HardMixVAF/#comments","text":"This function defines the objective function that depends on the given data and on theta. Note that the function does not return a scalar but a vector. The Matlab build-in optimizer (e.g., lsqnonlin) minimizes the sum of squared entries of this vector. This function may be converted into a Matlab executable file (.mex file) with the Matlab Coder to accelerate the objective function evaluation.","title":"Comments"},{"location":"code/objective_vec_HardMixVAF/#input-arguments","text":"paramters ( double ) - material parameters q_case ( double ) - see opt_input documentation q ( double ) - see opt_input documentation lambda_r ( double ) - see opt_input documentation lambda_p ( double ) - see opt_input documentation p ( double ) - see opt_input documentation n_eval ( double ) - see opt_input documentation u ( double ) - displacement data for every load step (every column corresponds to one load step) reaction ( double ) - reaction force data for every load step n_NR_local ( double ) - maximum number of Newton-Raphson iterations used for solving the local problem (return mapping algorithm) tol_NR_local ( double ) - stopping tolerance for the Newton-Raphson iteration used for solving the local problem (return mapping algorithm) CPlaneStress ( double ) - known elastic properties (stiffness matrix) SPlaneStress ( double ) - known elastic properties (compliance matrix) n_dof ( double ) - number of degrees of freedom in the mesh n_element ( double ) - number of finite elements in the mesh n_dof_per_element ( double ) - number of degrees of freedom per finite element element_dof ( double ) - degrees of freedom at each finite element element (each row provides all degrees of freedom at the corresponding finite element) Gauss_weights ( double ) - Gaussian quadrature weights n_Gauss_per_dim ( double ) - number of Gauss points per dimension detJ_GP ( double ) - determinant of the Jacobian at each Gauss point needed for mapping integrals between the reference and physical finite element B_GP ( double ) - help matrix at each Gauss point needed for calculating shape function derivatives dof_free ( double ) - free degrees of freedom dof_reaction ( double ) - degrees of freedom corresponding to reaction forces","title":"Input Arguments"},{"location":"code/objective_vec_HardMixVAF/#output-arguments","text":"cost ( double ) - vector, whose sum of squared entries must be minimized (note that the regularization term is included as the last entry of this vector)","title":"Output Arguments"},{"location":"code/opt_HardMix/","text":"OPT_HARDMIX - runs the optimization problem Comments Please make sure that the correct input is defined in opt_input_HardMix . The results are saved in the directory specified in opt_input_HardMix . Input Arguments none Output Arguments none","title":"opt_HardMix"},{"location":"code/opt_HardMix/#opt_hardmix-runs-the-optimization-problem","text":"","title":"OPT_HARDMIX - runs the optimization problem"},{"location":"code/opt_HardMix/#comments","text":"Please make sure that the correct input is defined in opt_input_HardMix . The results are saved in the directory specified in opt_input_HardMix .","title":"Comments"},{"location":"code/opt_HardMix/#input-arguments","text":"none","title":"Input Arguments"},{"location":"code/opt_HardMix/#output-arguments","text":"none","title":"Output Arguments"},{"location":"code/opt_input_HardMix/","text":"OPT_INPUT_HARDMIX - provides elementary definitions needed for the optimization problem Comments Please make sure that the correct path to the FEM data is specified. Input Arguments none Output Arguments in ( struct ) - contains information needed for the optimization problem in.use_mex ( logical ) - specifies if .mex file is used for the cost evaluation in.n_workers ( double ) - number of workers used for the parallel optimization in.datafile ( char ) - filename of the FEM dataset in.noise_level ( char ) - noise level to be considered (e.g., in.noise_level='' , in.noise_level='1' , in.noise_level='3' , in.noise_level='5' ) in.filter ( char ) - temporal data smoothing method (e.g., in.filter='' for no smoothing, in.filter='sgolay' for Savitzky-Golay smoothing) in.filter_length ( double ) - specifies the moving window length for the temporal smoothing in.n_feature ( double ) - number of features in.q_case ( double ) - specifies which norm to use during cost function calculation (e.g. in.q_case=0 for L2-norm) in.q ( double ) - specifies which norm to use during cost function calculation (e.g. in.q=2 for L2-norm) in.lambda_r ( double ) - weighting factor for net reaction force contributions in.lambda_p ( double ) - weighting factor for the sparsity promoting regularization term in.p ( double ) - specifies which norm to use for the sparsity promoting regularization in.lambda_p_factor ( double ) - lambda_p is multiplied by this factor to obtain solutions for different lambda_p in.n_lambda_p ( double ) - number of different values of lambda_p to be considered in.n_eval ( double ) - evaluate cost for every n_eval-th load step in.method ( char ) - method used for optimization in.MaxFunEvals ( double ) - maximum minimization function evaluations during each optimization process in.TolFun ( double ) - stopping criterion for optimization process based on minimization function value in.TolX ( double ) - stopping criterion for optimization process based on solution values in.MaxTime ( double ) - maximimum runtime of an optimization process in.theta_init ( double ) - initial guess yield surface parameters in.H_isotropic_init ( double ) - initial guess hardening parameters in.H_kinematic_init ( double ) - initial guess hardening parameters in.n_guess ( double ) - number of random initial guesses in.perturbation_guess_theta ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.perturbation_guess_H_isotropic ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.perturbation_guess_H_kinematic ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.save_path ( char ) - path for saving results","title":"opt_input_HardMix"},{"location":"code/opt_input_HardMix/#opt_input_hardmix-provides-elementary-definitions-needed-for-the-optimization-problem","text":"","title":"OPT_INPUT_HARDMIX - provides elementary definitions needed for the optimization problem"},{"location":"code/opt_input_HardMix/#comments","text":"Please make sure that the correct path to the FEM data is specified.","title":"Comments"},{"location":"code/opt_input_HardMix/#input-arguments","text":"none","title":"Input Arguments"},{"location":"code/opt_input_HardMix/#output-arguments","text":"in ( struct ) - contains information needed for the optimization problem in.use_mex ( logical ) - specifies if .mex file is used for the cost evaluation in.n_workers ( double ) - number of workers used for the parallel optimization in.datafile ( char ) - filename of the FEM dataset in.noise_level ( char ) - noise level to be considered (e.g., in.noise_level='' , in.noise_level='1' , in.noise_level='3' , in.noise_level='5' ) in.filter ( char ) - temporal data smoothing method (e.g., in.filter='' for no smoothing, in.filter='sgolay' for Savitzky-Golay smoothing) in.filter_length ( double ) - specifies the moving window length for the temporal smoothing in.n_feature ( double ) - number of features in.q_case ( double ) - specifies which norm to use during cost function calculation (e.g. in.q_case=0 for L2-norm) in.q ( double ) - specifies which norm to use during cost function calculation (e.g. in.q=2 for L2-norm) in.lambda_r ( double ) - weighting factor for net reaction force contributions in.lambda_p ( double ) - weighting factor for the sparsity promoting regularization term in.p ( double ) - specifies which norm to use for the sparsity promoting regularization in.lambda_p_factor ( double ) - lambda_p is multiplied by this factor to obtain solutions for different lambda_p in.n_lambda_p ( double ) - number of different values of lambda_p to be considered in.n_eval ( double ) - evaluate cost for every n_eval-th load step in.method ( char ) - method used for optimization in.MaxFunEvals ( double ) - maximum minimization function evaluations during each optimization process in.TolFun ( double ) - stopping criterion for optimization process based on minimization function value in.TolX ( double ) - stopping criterion for optimization process based on solution values in.MaxTime ( double ) - maximimum runtime of an optimization process in.theta_init ( double ) - initial guess yield surface parameters in.H_isotropic_init ( double ) - initial guess hardening parameters in.H_kinematic_init ( double ) - initial guess hardening parameters in.n_guess ( double ) - number of random initial guesses in.perturbation_guess_theta ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.perturbation_guess_H_isotropic ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.perturbation_guess_H_kinematic ( double ) - specifies the magnitude of perturbation applied to the preconditioning solution for generating random initial guesses in.save_path ( char ) - path for saving results","title":"Output Arguments"},{"location":"code/ordinary2engineering_strainV/","text":"ORDINARY2ENGINEERING_STRAINV - provides a matrix that transforms ordinary strains to engineering strains in Voigt notation Comments It is epsilonV_engineering = IV_ord * epsilonV_ordinary . epsilonV_ordinary is a vector containing the strain components in Voigt notation without a factor of two in front of the shear components. epsilonV_engineering is a vector containing the strain components in Voigt notation with a factor of two in front of the shear components. Assumptions: Voigt notation Input Arguments dim ( double ) - dimension (default: 3) Output Arguments IV_ord ( double ) - matrix such that epsilonV_engineering = IV_ord * epsilonV_ordinary","title":"ordinary2engineering_strainV"},{"location":"code/ordinary2engineering_strainV/#ordinary2engineering_strainv-provides-a-matrix-that-transforms-ordinary-strains-to-engineering-strains-in-voigt-notation","text":"","title":"ORDINARY2ENGINEERING_STRAINV - provides a matrix that transforms ordinary strains to engineering strains in Voigt notation"},{"location":"code/ordinary2engineering_strainV/#comments","text":"It is epsilonV_engineering = IV_ord * epsilonV_ordinary . epsilonV_ordinary is a vector containing the strain components in Voigt notation without a factor of two in front of the shear components. epsilonV_engineering is a vector containing the strain components in Voigt notation with a factor of two in front of the shear components. Assumptions: Voigt notation","title":"Comments"},{"location":"code/ordinary2engineering_strainV/#input-arguments","text":"dim ( double ) - dimension (default: 3)","title":"Input Arguments"},{"location":"code/ordinary2engineering_strainV/#output-arguments","text":"IV_ord ( double ) - matrix such that epsilonV_engineering = IV_ord * epsilonV_ordinary","title":"Output Arguments"},{"location":"code/selection_HardMix/","text":"SELECTION_HARDMIX - selects a sparse solution with high fitting accuracy Comments Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick). Input Arguments solutionfile ( char ) - filename of the solutionset Output Arguments none","title":"selection_HardMix"},{"location":"code/selection_HardMix/#selection_hardmix-selects-a-sparse-solution-with-high-fitting-accuracy","text":"","title":"SELECTION_HARDMIX - selects a sparse solution with high fitting accuracy"},{"location":"code/selection_HardMix/#comments","text":"Assumptions: plane stress, isotropic hardening (Voce), kinematic hardening (Armstrong-Frederick).","title":"Comments"},{"location":"code/selection_HardMix/#input-arguments","text":"solutionfile ( char ) - filename of the solutionset","title":"Input Arguments"},{"location":"code/selection_HardMix/#output-arguments","text":"none","title":"Output Arguments"},{"location":"code/selection_Lp_threshold/","text":"SELECTION_LP_THRESHOLD - selects from all choices of lambda_p a solution vector with both low cost and low regularization term Comments Given multiple solutions of material parameters and their corresponding costs and regularization terms, this function selects the solution which has both a low cost and a low regularization term. The selection procedure depends on one hyperparameter ( threshold_factor ), which influences how sparse the solution should be. Input Arguments theta ( double ) - multiple solutions of material parameters (every row corresponds to one solution) cost ( double ) - cost function values of the given solutions regularizer ( double ) - regularization term of the given solutions (without considering weighting factor lambda_p) threshold_factor ( double ) - factor for computing the cost threshold C^{th} Output Arguments theta_select ( double ) - selected solution of the material parameters","title":"`SELECTION_LP_THRESHOLD` - selects from all choices of `lambda_p` a solution vector with both low cost and low regularization term"},{"location":"code/selection_Lp_threshold/#selection_lp_threshold-selects-from-all-choices-of-lambda_p-a-solution-vector-with-both-low-cost-and-low-regularization-term","text":"","title":"SELECTION_LP_THRESHOLD - selects from all choices of lambda_p a solution vector with both low cost and low regularization term"},{"location":"code/selection_Lp_threshold/#comments","text":"Given multiple solutions of material parameters and their corresponding costs and regularization terms, this function selects the solution which has both a low cost and a low regularization term. The selection procedure depends on one hyperparameter ( threshold_factor ), which influences how sparse the solution should be.","title":"Comments"},{"location":"code/selection_Lp_threshold/#input-arguments","text":"theta ( double ) - multiple solutions of material parameters (every row corresponds to one solution) cost ( double ) - cost function values of the given solutions regularizer ( double ) - regularization term of the given solutions (without considering weighting factor lambda_p) threshold_factor ( double ) - factor for computing the cost threshold C^{th}","title":"Input Arguments"},{"location":"code/selection_Lp_threshold/#output-arguments","text":"theta_select ( double ) - selected solution of the material parameters","title":"Output Arguments"},{"location":"code/selection_best_random_HardMixVAF/","text":"SELECTION_BEST_RANDOM_HARDISONONLIN - selects from a set of solutions for each choice of lambda_p the lowest cost solution Comments Note that cost denotes here the total minimization function, i.e., including the regularization term. cost_without_regularizer denotes the cost without the weighted regularization term. Input Arguments solution ( struct ) - set of solutions Output Arguments solution_best_random ( struct ) - lowest cost solution for each choice of lambda_p","title":"selection_best_random_HardMixVAF"},{"location":"code/selection_best_random_HardMixVAF/#selection_best_random_hardisononlin-selects-from-a-set-of-solutions-for-each-choice-of-lambda_p-the-lowest-cost-solution","text":"","title":"SELECTION_BEST_RANDOM_HARDISONONLIN - selects from a set of solutions for each choice of lambda_p the lowest cost solution"},{"location":"code/selection_best_random_HardMixVAF/#comments","text":"Note that cost denotes here the total minimization function, i.e., including the regularization term. cost_without_regularizer denotes the cost without the weighted regularization term.","title":"Comments"},{"location":"code/selection_best_random_HardMixVAF/#input-arguments","text":"solution ( struct ) - set of solutions","title":"Input Arguments"},{"location":"code/selection_best_random_HardMixVAF/#output-arguments","text":"solution_best_random ( struct ) - lowest cost solution for each choice of lambda_p","title":"Output Arguments"},{"location":"code/selection_threshold/","text":"SELECTION_LP_THRESHOLD - selects from all choices of lambda_p a solution vector with both low cost and low regularization term Comments Given multiple solutions of material parameters and their corresponding costs and regularization terms, this function selects the solution which has both a low cost and a low regularization term. The selection procedure depends on a hyperparameter ( threshold_factor_cost ), which influences how sparse the solution should be, and a hyperparameter ( threshold_factor_parameters ), determining below which value parameters should be discarded. Input Arguments lambda_p ( double ) - regularization factors parameters ( double ) - multiple solutions of material parameters (every row corresponds to one solution) regularizer ( double ) - regularization terms of the given solutions (without considering weighting factor lambda_p) cost_without_regularizer ( double ) - cost function values of the given solutions minus the regularization terms (considering weighting factor lambda_p) threshold_factor_cost ( double ) - factor for computing the cost threshold C^{th} threshold_factor_parameters ( double ) - factor for computing the parameter threshold theta^{th} Output Arguments parameters_select ( double ) - selected solution of the material parameters","title":"selection_threshold"},{"location":"code/selection_threshold/#selection_lp_threshold-selects-from-all-choices-of-lambda_p-a-solution-vector-with-both-low-cost-and-low-regularization-term","text":"","title":"SELECTION_LP_THRESHOLD - selects from all choices of lambda_p a solution vector with both low cost and low regularization term"},{"location":"code/selection_threshold/#comments","text":"Given multiple solutions of material parameters and their corresponding costs and regularization terms, this function selects the solution which has both a low cost and a low regularization term. The selection procedure depends on a hyperparameter ( threshold_factor_cost ), which influences how sparse the solution should be, and a hyperparameter ( threshold_factor_parameters ), determining below which value parameters should be discarded.","title":"Comments"},{"location":"code/selection_threshold/#input-arguments","text":"lambda_p ( double ) - regularization factors parameters ( double ) - multiple solutions of material parameters (every row corresponds to one solution) regularizer ( double ) - regularization terms of the given solutions (without considering weighting factor lambda_p) cost_without_regularizer ( double ) - cost function values of the given solutions minus the regularization terms (considering weighting factor lambda_p) threshold_factor_cost ( double ) - factor for computing the cost threshold C^{th} threshold_factor_parameters ( double ) - factor for computing the parameter threshold theta^{th}","title":"Input Arguments"},{"location":"code/selection_threshold/#output-arguments","text":"parameters_select ( double ) - selected solution of the material parameters","title":"Output Arguments"},{"location":"code/volumetric_deviatoric_splitV/","text":"VOLUMETRIC_DEVIATORIC_SPLITV - applies the volumetric deviatoric split to the stress tensor in Voigt notation Comments It is sigmaV_vol = IV_vol * sigmaV and sigmaV_dev = IV_dev * sigmaV . Assumptions: Voigt notation Input Arguments dim ( double ) - dimension (default: 3) Output Arguments IV_vol ( double ) - matrix such that sigmaV_vol = IV_vol * sigmaV IV_dev ( double ) - matrix such that sigmaV_dev = IV_dev * sigmaV","title":"volumetric_deviatoric_splitV"},{"location":"code/volumetric_deviatoric_splitV/#volumetric_deviatoric_splitv-applies-the-volumetric-deviatoric-split-to-the-stress-tensor-in-voigt-notation","text":"","title":"VOLUMETRIC_DEVIATORIC_SPLITV - applies the volumetric deviatoric split to the stress tensor in Voigt notation"},{"location":"code/volumetric_deviatoric_splitV/#comments","text":"It is sigmaV_vol = IV_vol * sigmaV and sigmaV_dev = IV_dev * sigmaV . Assumptions: Voigt notation","title":"Comments"},{"location":"code/volumetric_deviatoric_splitV/#input-arguments","text":"dim ( double ) - dimension (default: 3)","title":"Input Arguments"},{"location":"code/volumetric_deviatoric_splitV/#output-arguments","text":"IV_vol ( double ) - matrix such that sigmaV_vol = IV_vol * sigmaV IV_dev ( double ) - matrix such that sigmaV_dev = IV_dev * sigmaV","title":"Output Arguments"}]}